/* ~~/tests/mitigations/paymentHash.spec.ts */

/**
 * Dear list,
 *
 * earlier last month, our team at LNbits discovered a rather interesting exploit which wich would
 * enable an attacker to create balances out of thin air by abusing a quirk in how invoices are
 * handled internally. We've patched this in LNbits version 0.10.5 and urge anyone to update ASAP if
 * you haven't done so already. I want to describe the attack here, since my gut feeling is that
 * carrying out the same exploit is possible in other Lightning applications. If you're working on
 * custodial wallets, payment processors, account management software, etc. you probably want to
 * read this.
 *
 * In short, the attacker was able to insert a bolt-11 payment hash of payment A into a different
 * payment, creating a malicious invoice B that can trick the backend into believing that B == A.
 *
 * Here is how it goes:
 *
 * - Attacker creates invoice A of amount 1000 sat in LNbits
 * - Attacker creates invoice B' of amount 1 sat on her own node
 * - Attacker deserializes B', inserts payment_hash(A) into payment_hash(B), re-signs the invoice,
 *   and serializes it again, producing malicious invoice B
 * - Attacker creates a new account in LNbits and pays B
 *
 * - LNbits backend uses payment_hash(B) to check whether this is an internal payment or a payment
 *   via LN
 * - Backend finds A in its database since we implicitly assume that payment_hash(A) commits to A
 *
 * ** This is the critical part! Payment hashes do *NOT* commit to any payment details (like amount)
 * but only to the preimage! **
 *
 * - Backend settles payment internally by crediting A debiting B
 * - Attacker has "created" 999 sats
 *
 * Mitigation:
 *
 * The mitigation is quite simple. Backends should either use self-generated unique "checking id's"
 * for looking up internal payments or use additional checks to make sure that the invoice details
 * have not been messed around with (e.g., asserting amount(A) == amount(B)).
 *
 * Lessons:
 *
 * I think there are two lessons here. First, it's good to realize the level of sophistication of
 * LN-savvy attackers. This attack clearly involves a fundamental understanding of bolt-11 and
 * requires custom tooling to produce the malicious invoice.
 *
 * The second lesson is more valuable: The "payment hash" of an invoice is not a "payment" hash but
 * merely a "preimage" hash – and nothing else. Naming this field as such increases the chance of
 * developers implicitly assuming that the hash commits to payment details like amount, pubkey, etc.
 * I will from now on call this simply the "preimage hash" and invite you to do so too.
 *
 * Best
 * Calle
 *
 * @see https://lists.linuxfoundation.org/pipermail/lightning-dev/2023-June/003983.html
 */

// imports
import { ECPair } from 'bitcoinjs-lib'
import { InvoiceJSON, UserAuth } from '@/types'
import { LightningService } from '@/server/services/lightning'
import { afterAll, beforeAll, describe, expect, it } from 'vitest'
import { decode as decodeBOLT11, sign as signBOLT11 } from 'bolt11'
import { externalLND } from 'τ/configs'
import lndkrub from '@/index'
import { promisify } from 'node:util'
import supertest from 'supertest'

let lndAttacker: LightningService

afterAll(() => {
  lndkrub.emit('event:shutdown')
})

beforeAll(async () => {
  lndAttacker = new LightningService(
    externalLND.host,
    externalLND.macaroonPath,
    externalLND.port,
    externalLND.tlsCertPath
  )
  lndkrub.emit('event:startup')
})

describe('Attacker creates external invoice with reused paymentHash to drain LNDKrub', () => {
  let amountInvoiceA: number = 1000
  let amountInvoiceB: number = 1
  let attacker = ECPair.makeRandom()
  let authHeaders: { Authorization: string }
  let bolt11: null | string = null
  let bolt11Attack: null | string = null
  let login: null | string = null
  let password: null | string = null
  beforeAll(async () => {
    await supertest(lndkrub)
      .post('/create')
      .then((response: { body: { login: string; password: string } }) => {
        login = response.body.login
        password = response.body.password
      })
    await supertest(lndkrub)
      .post('/auth')
      .send({ login, password })
      .then((response: { body: UserAuth }) => {
        let { accessToken } = response.body
        authHeaders = { Authorization: `Bearer ${accessToken}` }
      })
    await supertest(lndkrub)
      .post('/addinvoice')
      .set(authHeaders)
      .send({ memo: 'attack', amt: amountInvoiceA })
      .then((response: { body: InvoiceJSON }) => {
        let { payment_request } = response.body
        bolt11 = payment_request
      })
    let paymentTag = decodeBOLT11(bolt11).tags.find(tag => tag.tagName === 'payment_hash')

    // attack invoice
    let invoice = await promisify(lndAttacker.addInvoice).bind(lndAttacker)({
      value: 1,
      memo: 'attack',
    })
    let attack = decodeBOLT11(invoice.payment_request)
    attack.tags = attack.tags.filter(tag => tag.tagName !== 'payment_hash')
    attack.tags.push({ tagName: 'payment_hash', data: paymentTag.data })
    bolt11Attack = signBOLT11(attack, attacker.privateKey).paymentRequest
  })
  it('Unsuccessfully drains satoshis from invoice A issuer and subtracts own balance', async () => {
    let attackerLogin: string
    let attackerPassword: string
    let attackerAuth: { Authorization: string }
    await supertest(lndkrub)
      .post('/create')
      .then((response: { body: { login: string; password: string } }) => {
        attackerLogin = response.body.login
        attackerPassword = response.body.password
      })
    await supertest(lndkrub)
      .post('/auth')
      .send({ login: attackerLogin, password: attackerPassword })
      .then((response: { body: UserAuth }) => {
        let { accessToken } = response.body
        attackerAuth = { Authorization: `Bearer ${accessToken}` }
      })
    await supertest(lndkrub).post('/faucet').set(attackerAuth).send({ amt: 1000 })
    await supertest(lndkrub)
      .get('/balance')
      .set(attackerAuth)
      .then((response: { body: { BTC: { AvailableBalance: number } } }) => {
        expect(response.body).toStrictEqual({
          BTC: {
            AvailableBalance: 1000,
          },
        })
      })
    await supertest(lndkrub)
      .post('/payinvoice')
      .send({ invoice: bolt11Attack })
      .set(attackerAuth)
      .then((response: { body: { decoded: InvoiceJSON } }) => {
        let { num_satoshis } = response.body.decoded
        expect(+num_satoshis).toBe(amountInvoiceB)
      })
    await supertest(lndkrub)
      .get('/balance')
      .set(attackerAuth)
      .then((response: { body: { BTC: { AvailableBalance: number } } }) => {
        expect(response.body).toStrictEqual({
          BTC: {
            AvailableBalance: 999,
          },
        })
      })
  })
})
